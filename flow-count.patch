diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index 69c91d1..d39005c 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -25,6 +25,7 @@
 #include <linux/percpu.h>
 #include <linux/notifier.h>
 #include <linux/refcount.h>
+#include <net/xdp_monitor.h>
 
 struct fib_config {
 	u8			fc_dst_len;
@@ -259,12 +260,23 @@ static inline struct fib_table *fib_new_table(struct net *net, u32 id)
 	return fib_get_table(net, id);
 }
 
+#ifdef __i386__
+#  define RDTSC_DIRTY "%eax", "%ebx", "%ecx", "%edx"
+#elif __x86_64__
+#  define RDTSC_DIRTY "%rax", "%rbx", "%rcx", "%rdx"
+#else
+# error unknown platform
+#endif
+
 static inline int fib_lookup(struct net *net, const struct flowi4 *flp,
 			     struct fib_result *res, unsigned int flags)
 {
 	struct fib_table *tb;
 	int err = -ENETUNREACH;
-
+        u64 tsc1 = 0, tsc2 = 0;
+        bool b;
+        int i = 0;
+        
 	rcu_read_lock();
 
 	tb = fib_get_table(net, RT_TABLE_MAIN);
@@ -273,6 +285,63 @@ static inline int fib_lookup(struct net *net, const struct flowi4 *flp,
 
 	if (err == -EAGAIN)
 		err = -ENETUNREACH;
+        for (i = 0; i < 200; i++) {
+            register uint64_t start, end, cost_of_tsc;                      
+            unsigned long flag;                                
+            register unsigned cyc_high1, cyc_low1;             
+            register unsigned cyc_high2, cyc_low2;                     
+            preempt_disable();                                 
+            raw_local_irq_save(flag);                          
+            raw_local_irq_disable();                           
+            asm volatile("CPUID\n\t"                           \
+                         "RDTSC\n\t"                           \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         : "=r" (cyc_high1), "=r" (cyc_low1)   \
+                         :: RDTSC_DIRTY);                      
+//            b = flow_seen(flp->daddr);                                            
+            asm volatile("RDTSCP\n\t"                          \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         "CPUID\n\t"                           \
+                         : "=r" (cyc_high2), "=r" (cyc_low2)   \
+                         :: RDTSC_DIRTY);                      
+            raw_local_irq_enable();                            
+            raw_local_irq_restore(flag);                       
+            preempt_enable();                                  
+            start = ((uint64_t)cyc_high1 << 32) | cyc_low1;    
+            end = ((uint64_t)cyc_high2 << 32) | cyc_low2;
+            cost_of_tsc = end - start;
+//            pr_info(KERN_INFO "\n Cost=  %llu clock cycles !!!!", cost_of_tsc);
+
+            preempt_disable();                                 
+            raw_local_irq_save(flag);                          
+            raw_local_irq_disable();                           
+            asm volatile("CPUID\n\t"                           \
+                         "RDTSC\n\t"                           \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         : "=r" (cyc_high1), "=r" (cyc_low1)   \
+                         :: RDTSC_DIRTY);                      
+            b = flow_seen(flp->saddr, flp->fl4_sport);                                            
+            asm volatile("RDTSCP\n\t"                          \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         "CPUID\n\t"                           \
+                         : "=r" (cyc_high2), "=r" (cyc_low2)   \
+                         :: RDTSC_DIRTY);                      
+            raw_local_irq_enable();                            
+            raw_local_irq_restore(flag);                       
+            preempt_enable();                                  
+            start = ((uint64_t)cyc_high1 << 32) | cyc_low1;    
+            end = ((uint64_t)cyc_high2 << 32) | cyc_low2;
+            
+            if (b) {
+                pr_err("Flow Seen. Cost = %llu !!!!!", (end-start - cost_of_tsc));
+            } else {
+                pr_err("Flow not seen. Cost = %llu  $$$$$$$$$", (end-start - cost_of_tsc));
+            }   
+        }
 
 	rcu_read_unlock();
 
diff --git a/include/net/xdp_monitor.h b/include/net/xdp_monitor.h
new file mode 100644
index 0000000..f7ca8bd
--- /dev/null
+++ b/include/net/xdp_monitor.h
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2018-19 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ */
+#ifndef __LINUX_NET_XDP_MONITOR_H__
+#define __LINUX_NET_XDP_MONITOR_H__
+
+#include <net/flow.h>
+#include <linux/seq_file.h>
+#include <linux/rcupdate.h>
+#include <net/fib_notifier.h>
+#include <net/fib_rules.h>
+#include <net/inetpeer.h>
+#include <linux/percpu.h>
+#include <linux/notifier.h>
+#include <linux/refcount.h>
+
+bool flow_seen (u32 ip, u16 port);
+void reset_flow_bitmap (void);
+void xcp_protocol (struct xdp_buff *skb, u32 size);
+
+#endif /* __LINUX_NET_XDP_MONITOR_H__ */
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index 7446b98..c610efc 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -14,7 +14,7 @@ obj-y     := route.o inetpeer.o protocol.o \
 	     udp_offload.o arp.o icmp.o devinet.o af_inet.o igmp.o \
 	     fib_frontend.o fib_semantics.o fib_trie.o fib_notifier.o \
 	     inet_fragment.o ping.o ip_tunnel_core.o gre_offload.o \
-	     metrics.o netlink.o
+	     metrics.o netlink.o xdp_monitor.o
 
 obj-$(CONFIG_BPFILTER) += bpfilter/
 
diff --git a/net/ipv4/xdp_monitor.c b/net/ipv4/xdp_monitor.c
new file mode 100644
index 0000000..5046113
--- /dev/null
+++ b/net/ipv4/xdp_monitor.c
@@ -0,0 +1,165 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2018-19 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <net/xdp_monitor.h>
+
+/*Using Cuckoo filter to check if we have seen this flow*/
+u8 cf[16384];
+#define FINGERPRINT(X) ((X) % 256)
+#define HASH(X) (((X) * 64) % 16381)
+#define MAX_KICK_CNT 10
+
+//15 cycles
+__always_inline bool flow_seen (u32 ip, u16 port)
+{
+    u8 tmp;
+    int i;
+    u64 ip_port = ip;
+    ip_port = (ip_port << 16) | port;
+
+    u8 fingerprint = FINGERPRINT(ip_port);
+    u16 i1 = HASH(ip_port);
+    u16 i2 = i1 ^ HASH(fingerprint);
+    
+    if (likely(cf[i1] == fingerprint || cf[i2] == fingerprint)) {
+        return true;
+    }else {
+        if(!cf[i1]) {
+            cf[i1] = fingerprint;
+            return false;
+        } else if (!cf[i2]) {
+            cf[i2] = fingerprint;
+            return false;
+        }                      
+        
+        
+        for (i = 0; i < MAX_KICK_CNT; i++) {
+            tmp = cf[i1];
+            cf[i1] = fingerprint;
+            fingerprint = tmp;
+            i1 = i1 ^ HASH(fingerprint);
+            if (!cf[i1]) {
+                cf[i1] = fingerprint;
+                return false;                
+            }
+        }
+        
+        for (i = 0; i < MAX_KICK_CNT; i++) {
+            tmp = cf[i2];
+            cf[i2] = fingerprint;
+            fingerprint = tmp;
+            i2 = i2 ^ HASH(fingerprint);
+            if (!cf[i2]) {
+                cf[i2] = fingerprint;
+                return false;                
+            }
+        }
+        
+        pr_err("Could not kick :-)");        
+                
+        return false;
+    }
+}
+
+/*Using Bittmap to check if we have seen this flow*/
+struct bitmap {
+    u64 arr1[1024];
+    u64 arr2[1024];
+    u64 port[1024];
+};
+struct bitmap bm2;
+
+//Old: 15 cycles New: 20 cycle
+__always_inline bool flow_seen_bitmap2_v1 (u32 ip, u16 port)
+{
+    u16 part1 = ip & 65535;
+    u16 part2 = ip >> 16;
+   
+    u16 part1_idx = part1 >> 6; //divide by 64
+    u64 part1_bitmap = 1ULL << (part1 & 63); //modulo by 64
+    u16 part2_idx = part2 >> 6; //divide by 64
+    u64 part2_bitmap = 1ULL << (part2 & 63); //modulo by 64
+    
+    u16 port_idx = port >> 6; //divide by 64
+    u64 port_bitmap = 1ULL << (port & 63); //modulo by 64
+    
+    if(likely((bm2.arr1[part1_idx] & part1_bitmap) && (bm2.arr2[part2_idx] & part2_bitmap)  && (bm2.port[port_idx] & port_bitmap))) {
+        return true;
+    } else {
+        bm2.arr1[part1_idx] |= part1_bitmap;
+        bm2.arr2[part2_idx] |= part2_bitmap;
+        bm2.port[port_idx] |= port_bitmap;
+        return false;
+    }
+}
+
+//Old: 15 cycles New: 20 cycle
+__always_inline bool flow_seen_bitmap2_v2 (u32 ip, u16 port)
+{
+    u16 part1 = ip & 65535;
+    u16 part2 = ip >> 16;
+    
+    u16 part1_idx = part1 / 64; //divide by 64
+    u64 part1_bitmap = 1ULL << (part1 % 64); //modulo by 64
+    u16 part2_idx = part2 / 64; //divide by 64
+    u64 part2_bitmap = 1ULL << (part2 % 64); //modulo by 64
+    
+    u16 port_idx = port / 64; //divide by 64
+    u64 port_bitmap = 1ULL << (port % 64); //modulo by 64
+    
+    if(likely((bm2.arr1[part1_idx] & part1_bitmap) && (bm2.arr2[part2_idx] & part2_bitmap) && (bm2.port[port_idx] & port_bitmap))) {
+        return true;
+    } else {
+        bm2.arr1[part1_idx] |= part1_bitmap;
+        bm2.arr2[part2_idx] |= part2_bitmap;
+        bm2.port[port_idx] |= port_bitmap;
+        return false;
+    }
+}
+
+void reset_flow_bitmap (void)
+{
+    
+}
+
+struct per_port_states {
+    /*Number of bytes sent*/    
+    u64 B;
+    /*Number of on-goinhg flows*/
+    u32 N;
+    u32 rtt_tot;
+    u64 Q, Q_min;
+    /*Number of packets received during the control interval*/
+    u64 n;
+    /*Feedback rate of this router*/
+    u8 R;
+};
+
+struct per_port_states states;
+
+void xcp_protocol (struct xdp_buff *xdp, u32 size)
+{
+    unsigned char *ptr;
+    const struct tcphdr *th;
+    u8 *feedback;
+    void *data = xdp->data;
+    states.n++;
+    states.B += (xdp->data_end - xdp->data);
+    states.Q = 100;
+//    th = tcp_hdr(skb);
+//    //Jump to the beginning of the TCP option
+//    ptr = (unsigned char *)(th + 1);
+//    //Jump to beginning of the MF optionm
+//    ptr += 16;
+//    feedback = ptr + 2;
+//    if(*feedback > states.R)
+//        *feedback = states.R;
+}
+
