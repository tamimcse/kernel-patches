diff --git a/include/net/xdp_monitor.h b/include/net/xdp_monitor.h
new file mode 100644
index 0000000..b264ab2
--- /dev/null
+++ b/include/net/xdp_monitor.h
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2018-19 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ */
+#ifndef __LINUX_NET_XDP_MONITOR_H__
+#define __LINUX_NET_XDP_MONITOR_H__
+
+#include <net/flow.h>
+#include <linux/seq_file.h>
+#include <linux/rcupdate.h>
+#include <net/fib_notifier.h>
+#include <net/fib_rules.h>
+#include <net/inetpeer.h>
+#include <linux/percpu.h>
+#include <linux/notifier.h>
+#include <linux/refcount.h>
+#include <linux/ip.h>
+#include <linux/timer.h>
+
+struct pkthdr {
+        /*Ethernet header starts here. */
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	__be16		h_proto;		/* packet type ID field	*/
+        
+        /*IP header starts here. */
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__be16	tot_len;
+	__be16	id;
+	__be16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__sum16	check_ip;
+	__be32	saddr;
+	__be32	daddr;
+	/*The IP header options start here. */
+        /*TCP header starts here. */        
+	__be16	source;
+	__be16	dest;
+	__be32	seq;
+	__be32	ack_seq;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u16	res1:4,
+		doff:4,
+		fin:1,
+		syn:1,
+		rst:1,
+		psh:1,
+		ack:1,
+		urg:1,
+		ece:1,
+		cwr:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u16	doff:4,
+		res1:4,
+		cwr:1,
+		ece:1,
+		urg:1,
+		ack:1,
+		psh:1,
+		rst:1,
+		syn:1,
+		fin:1;
+#else
+#error	"Adjust your <asm/byteorder.h> defines"
+#endif	
+	__be16	window;
+	__sum16	check_tcp;
+	__be16	urg_ptr;
+	/*The TCP header options start here. */
+        u32 tcp_op1;
+        u16 tcp_op2;
+        /*TCP MF option header starts here. */
+        u8	mf_op_len;
+        u8 mf_op_req_thput;           /* Required throughput in MF */ 
+        u8 mf_op_cur_thput;           /* Current throughput in MF */
+        u8 mf_op_feedback_thput;      /* Feedback throughput in MF */
+        u8 mf_op_prop_delay_est;
+};
+
+struct per_port_states {
+    /*Number of bytes sent*/    
+    u64 B;
+    /*Number of on-goinhg flows*/
+    u32 N;
+    u64 Q;
+    /*Number of packets received during the control interval*/
+    u64 n;
+    /*Feedback rate of this router*/
+    u64 R;
+    u32 rtt_tot, rtt_a;
+};
+
+bool flow_seen (u32 ip, u16 port);
+void reset_flow_bitmap (void);
+void xcp_protocol (struct xdp_buff *skb, u32 size);
+int xcp_init(void);
+void reset_flow_bitmap (void);
+
+#endif /* __LINUX_NET_XDP_MONITOR_H__ */
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index 7446b98..c610efc 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -14,7 +14,7 @@ obj-y     := route.o inetpeer.o protocol.o \
 	     udp_offload.o arp.o icmp.o devinet.o af_inet.o igmp.o \
 	     fib_frontend.o fib_semantics.o fib_trie.o fib_notifier.o \
 	     inet_fragment.o ping.o ip_tunnel_core.o gre_offload.o \
-	     metrics.o netlink.o
+	     metrics.o netlink.o xdp_monitor.o
 
 obj-$(CONFIG_BPFILTER) += bpfilter/
 
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 1fbe2f8..6d75fd2 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -120,6 +120,7 @@
 #include <linux/mroute.h>
 #endif
 #include <net/l3mdev.h>
+#include <net/xdp_monitor.h>
 
 #include <trace/events/sock.h>
 
@@ -1965,6 +1966,8 @@ static int __init inet_init(void)
 	udplite4_register();
 
 	ping_init();
+        
+        xcp_init();
 
 	/*
 	 *	Set the ICMP layer up
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 3196cf5..127273d 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -130,6 +130,7 @@
 #include <linux/inetdevice.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
+#include <net/xdp_monitor.h>
 
 #include <net/snmp.h>
 #include <net/ip.h>
@@ -148,6 +149,14 @@
 #include <linux/netlink.h>
 #include <net/dst_metadata.h>
 
+#ifdef __i386__
+#  define RDTSC_DIRTY "%eax", "%ebx", "%ecx", "%edx"
+#elif __x86_64__
+#  define RDTSC_DIRTY "%rax", "%rbx", "%rcx", "%rdx"
+#else
+# error unknown platform
+#endif
+
 /*
  *	Process Router Attention IP option (RFC 2113)
  */
@@ -516,11 +525,76 @@ static struct sk_buff *ip_rcv_core(struct sk_buff *skb, struct net *net)
 int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 	   struct net_device *orig_dev)
 {
+        u64 tsc1 = 0, tsc2 = 0;
+        int i = 0;
+        
 	struct net *net = dev_net(dev);
 
 	skb = ip_rcv_core(skb, net);
 	if (skb == NULL)
 		return NET_RX_DROP;
+
+        struct xdp_buff *xdp = kmalloc(sizeof(*xdp), GFP_KERNEL);
+        xdp->data = skb->data;
+        xdp->data_end = skb->data + (skb->len - skb->data_len);
+        xdp->data_meta = skb;
+        
+        for (i = 0; i < 200; i++) {
+            register uint64_t start, end, cost_of_tsc;                      
+            unsigned long flag;                                
+            register unsigned cyc_high1, cyc_low1;             
+            register unsigned cyc_high2, cyc_low2;                     
+            preempt_disable();                                 
+            raw_local_irq_save(flag);                          
+            raw_local_irq_disable();                           
+            asm volatile("CPUID\n\t"                           \
+                         "RDTSC\n\t"                           \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         : "=r" (cyc_high1), "=r" (cyc_low1)   \
+                         :: RDTSC_DIRTY);                      
+//            b = flow_seen(flp->daddr);                                            
+            asm volatile("RDTSCP\n\t"                          \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         "CPUID\n\t"                           \
+                         : "=r" (cyc_high2), "=r" (cyc_low2)   \
+                         :: RDTSC_DIRTY);                      
+            raw_local_irq_enable();                            
+            raw_local_irq_restore(flag);                       
+            preempt_enable();                                  
+            start = ((uint64_t)cyc_high1 << 32) | cyc_low1;    
+            end = ((uint64_t)cyc_high2 << 32) | cyc_low2;
+            cost_of_tsc = end - start;
+//            pr_info(KERN_INFO "\n Cost=  %llu clock cycles !!!!", cost_of_tsc);
+
+            preempt_disable();                                 
+            raw_local_irq_save(flag);                          
+            raw_local_irq_disable();                           
+            asm volatile("CPUID\n\t"                           \
+                         "RDTSC\n\t"                           \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         : "=r" (cyc_high1), "=r" (cyc_low1)   \
+                         :: RDTSC_DIRTY);                      
+            xcp_protocol(xdp, skb->len - skb->data_len);                                            
+            asm volatile("RDTSCP\n\t"                          \
+                         "mov %%edx, %0\n\t"                   \
+                         "mov %%eax, %1\n\t"                   \
+                         "CPUID\n\t"                           \
+                         : "=r" (cyc_high2), "=r" (cyc_low2)   \
+                         :: RDTSC_DIRTY);                      
+            raw_local_irq_enable();                            
+            raw_local_irq_restore(flag);                       
+            preempt_enable();                                  
+            start = ((uint64_t)cyc_high1 << 32) | cyc_low1;    
+            end = ((uint64_t)cyc_high2 << 32) | cyc_low2;
+            
+            pr_err("Cost of XCP = %llu !!!!!", (end - start - cost_of_tsc));   
+        }
+        
+        
+        
 	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
 		       net, NULL, skb, dev, NULL,
 		       ip_rcv_finish);
diff --git a/net/ipv4/xdp_monitor.c b/net/ipv4/xdp_monitor.c
new file mode 100644
index 0000000..a947ee1
--- /dev/null
+++ b/net/ipv4/xdp_monitor.c
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2018-19 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <net/xdp_monitor.h>
+
+/*Using Cuckoo filter to check if we have seen this flow*/
+u8 cf[16384];
+#define FINGERPRINT(X) ((X) % 256)
+#define HASH(X) (((X) * 64) % 16381)
+#define MAX_KICK_CNT 10
+
+//15 cycles
+__always_inline bool flow_seen_cuckoo_filter (u32 ip, u16 port)
+{
+    u8 tmp;
+    int i;
+    u64 ip_port = ip;
+    ip_port = (ip_port << 16) | port;
+
+    u8 fingerprint = FINGERPRINT(ip_port);
+    u16 i1 = HASH(ip_port);
+    u16 i2 = i1 ^ HASH(fingerprint);
+    
+    if (likely(cf[i1] == fingerprint || cf[i2] == fingerprint)) {
+        return true;
+    }else {
+        if(!cf[i1]) {
+            cf[i1] = fingerprint;
+            return false;
+        } else if (!cf[i2]) {
+            cf[i2] = fingerprint;
+            return false;
+        }                      
+        
+        
+        for (i = 0; i < MAX_KICK_CNT; i++) {
+            tmp = cf[i1];
+            cf[i1] = fingerprint;
+            fingerprint = tmp;
+            i1 = i1 ^ HASH(fingerprint);
+            if (!cf[i1]) {
+                cf[i1] = fingerprint;
+                return false;                
+            }
+        }
+        
+        for (i = 0; i < MAX_KICK_CNT; i++) {
+            tmp = cf[i2];
+            cf[i2] = fingerprint;
+            fingerprint = tmp;
+            i2 = i2 ^ HASH(fingerprint);
+            if (!cf[i2]) {
+                cf[i2] = fingerprint;
+                return false;                
+            }
+        }
+        
+        pr_err("Could not kick :-)");        
+                
+        return false;
+    }
+}
+
+/*Using Bittmap to check if we have seen this flow*/
+struct bitmap {
+    u64 arr1[1024];
+    u64 arr2[1024];
+    u64 port[1024];
+};
+struct bitmap bm2;
+
+//Old: 15 cycles New: 20 cycle
+__always_inline bool flow_seen (u32 ip, u16 port)
+{
+    u16 part1 = ip & 65535;
+    u16 part2 = ip >> 16;
+   
+    u16 part1_idx = part1 >> 6; //divide by 64
+    u64 part1_bitmap = 1ULL << (part1 & 63); //modulo by 64
+    u16 part2_idx = part2 >> 6; //divide by 64
+    u64 part2_bitmap = 1ULL << (part2 & 63); //modulo by 64
+    
+    u16 port_idx = port >> 6; //divide by 64
+    u64 port_bitmap = 1ULL << (port & 63); //modulo by 64
+    
+    if(likely((bm2.arr1[part1_idx] & part1_bitmap) && (bm2.arr2[part2_idx] & part2_bitmap)  && (bm2.port[port_idx] & port_bitmap))) {
+        return true;
+    } else {
+        bm2.arr1[part1_idx] |= part1_bitmap;
+        bm2.arr2[part2_idx] |= part2_bitmap;
+        bm2.port[port_idx] |= port_bitmap;
+        return false;
+    }
+}
+
+//Old: 15 cycles New: 20 cycle
+__always_inline bool flow_seen_bitmap2_v2 (u32 ip, u16 port)
+{
+    u16 part1 = ip & 65535;
+    u16 part2 = ip >> 16;
+    
+    u16 part1_idx = part1 / 64; //divide by 64
+    u64 part1_bitmap = 1ULL << (part1 % 64); //modulo by 64
+    u16 part2_idx = part2 / 64; //divide by 64
+    u64 part2_bitmap = 1ULL << (part2 % 64); //modulo by 64
+    
+    u16 port_idx = port / 64; //divide by 64
+    u64 port_bitmap = 1ULL << (port % 64); //modulo by 64
+    
+    if(likely((bm2.arr1[part1_idx] & part1_bitmap) && (bm2.arr2[part2_idx] & part2_bitmap) && (bm2.port[port_idx] & port_bitmap))) {
+        return true;
+    } else {
+        bm2.arr1[part1_idx] |= part1_bitmap;
+        bm2.arr2[part2_idx] |= part2_bitmap;
+        bm2.port[port_idx] |= port_bitmap;
+        return false;
+    }
+}
+
+void reset_flow_bitmap (void)
+{
+    memset(&bm2, 0, sizeof(bm2));
+}
+
+struct per_port_states states;
+
+__always_inline void xcp_protocol (struct xdp_buff *xdp, u32 size)
+{
+    struct iphdr *iph;
+    const struct tcphdr *th;
+    unsigned char *ptr;
+    u64 Q;
+    u8 *feedback;
+    iph = (struct iphdr *)(xdp->data + ETH_HLEN);
+    if (unlikely(iph->version != 4))
+        return;
+    //Multiply by 4
+    th = (struct tcphdr *)(iph + (iph->ihl << 2));
+    states.n++;
+    states.B += (xdp->data_end - xdp->data);
+    Q = 100;
+    if(states.Q > Q)
+        states.Q = Q;
+//    pr_err("source ip=%pI4 port=%d", &(iph->saddr), th->source);
+
+/*    if(unlikely(!flow_seen(iph->saddr, th->source))){
+        states.N++;
+    }*/
+    
+    //Jump to the beginning of the TCP option and then beginning of the MF option and then feedback field in MF option
+    feedback = (unsigned char *)(th + sizeof(*th) + 6 + 2);
+    states.rtt_tot += *(feedback + 1);
+//        pr_info("feedback= %d, rate= %lld", *feedback, rate);
+    if(*feedback > states.R)
+        *feedback = states.R;
+}
+
+static struct timer_list timer;
+
+void calc_xcp_rate( struct timer_list *t )
+{
+    u64 S = states.rtt_a == 0 ? 2000 : 2000 - states.B/states.rtt_a;
+    states.rtt_a = states.n == 0 ? 200 : states.rtt_tot/states.n;
+    states.R = states.N == 0 ? 2000 : states.R + ((400 * states.rtt_a * S - 226 * states.Q)/(1000 * states.N));
+    mod_timer(&timer, jiffies + msecs_to_jiffies(states.rtt_a));
+    pr_err("In calc_xcp_rate. B=%llu RTT_a=%u S=%llu Q=%llu N=%u %llu", states.B, states.rtt_a, S, states.Q, states.N, states.R);	
+
+    states.N = 0;
+    states.n = 0;
+    states.B = 0;
+    states.rtt_tot = 0;
+    states.Q = 300000;
+    reset_flow_bitmap();
+}
+
+int xcp_init(void)
+{
+  /* setup your timer to call the callback */
+//  timer_setup(&timer, calc_xcp_rate, 0);
+  /* setup timer interval to 200 msecs */
+//  mod_timer(&timer, jiffies + msecs_to_jiffies(200));
+  states.rtt_a = 200;
+  states.n = 200;
+  states.N = 200;
+  states.R = 200;
+  states.B = 400;
+  states.Q = 0;
+  return 0;
+}
+
+
diff --git a/samples/Makefile b/samples/Makefile
index bd601c0..4debee1 100644
--- a/samples/Makefile
+++ b/samples/Makefile
@@ -3,4 +3,4 @@
 obj-$(CONFIG_SAMPLES)	+= kobject/ kprobes/ trace_events/ livepatch/ \
 			   hw_breakpoint/ kfifo/ kdb/ hidraw/ rpmsg/ seccomp/ \
 			   configfs/ connector/ v4l/ trace_printk/ \
-			   vfio-mdev/ statx/ qmi/
+			   vfio-mdev/ statx/ qmi/ bpf/
diff --git a/samples/bpf/Makefile b/samples/bpf/Makefile
index 36f9f41..8bc7f5f 100644
--- a/samples/bpf/Makefile
+++ b/samples/bpf/Makefile
@@ -51,6 +51,7 @@ hostprogs-y += cpustat
 hostprogs-y += xdp_adjust_tail
 hostprogs-y += xdpsock
 hostprogs-y += xdp_fwd
+hostprogs-y += xcp_router
 hostprogs-y += task_fd_query
 hostprogs-y += xdp_sample_pkts
 
@@ -107,6 +108,7 @@ cpustat-objs := bpf_load.o cpustat_user.o
 xdp_adjust_tail-objs := xdp_adjust_tail_user.o
 xdpsock-objs := xdpsock_user.o
 xdp_fwd-objs := xdp_fwd_user.o
+xcp_router-objs := xcp_router_user.o
 task_fd_query-objs := bpf_load.o task_fd_query_user.o $(TRACE_HELPERS)
 xdp_sample_pkts-objs := xdp_sample_pkts_user.o $(TRACE_HELPERS)
 
@@ -164,6 +166,7 @@ always += cpustat_kern.o
 always += xdp_adjust_tail_kern.o
 always += xdpsock_kern.o
 always += xdp_fwd_kern.o
+always += xcp_router_kern.o
 always += task_fd_query_kern.o
 always += xdp_sample_pkts_kern.o
 
diff --git a/samples/bpf/xcp_router_kern.c b/samples/bpf/xcp_router_kern.c
new file mode 100644
index 0000000..f324793
--- /dev/null
+++ b/samples/bpf/xcp_router_kern.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2017-18 David Ahern <dsahern@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+#define KBUILD_MODNAME "foo"
+#include <uapi/linux/bpf.h>
+#include <linux/in.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/xdp_monitor.h>
+
+#include "bpf_helpers.h"
+
+struct bpf_map_def SEC("maps") states_map = {
+	.type		= BPF_MAP_TYPE_PERCPU_ARRAY,
+	.key_size	= sizeof(u32),
+	.value_size	= sizeof(struct per_port_states),
+	.max_entries	= 1,
+};
+
+/*This name needs to match to that of the file name*/
+SEC("xcp_router")
+int xcp_router_prog(struct xdp_md *ctx)
+{
+    void *data_end = (void *)(long)ctx->data_end;
+    void *data = (void *)(long)ctx->data;
+    int len = data_end - data;
+    struct pkthdr *ph = data;
+    struct per_port_states *states;
+    u32 key = 0;
+    u64 Q;
+    struct timer_list *timer;
+
+    if (data + 67 > data_end)
+            return XDP_DROP;
+    
+    if (unlikely(ph->version != 4))
+        return XDP_DROP;
+
+    states = bpf_map_lookup_elem(&states_map, &key);
+    if (!states)
+            return XDP_ABORTED;
+    
+    states->n++;
+    states->B += len;
+    Q = 100;
+    if(states->Q > Q)
+        states->Q = Q;
+    
+    states->rtt_tot += ph->mf_op_prop_delay_est;
+    if(ph->mf_op_feedback_thput > states->R)
+        ph->mf_op_feedback_thput = states->R;
+        
+    return XDP_PASS;
+}
+
+char _license[] SEC("license") = "GPL";
diff --git a/samples/bpf/xcp_router_user.c b/samples/bpf/xcp_router_user.c
new file mode 100644
index 0000000..5889d67
--- /dev/null
+++ b/samples/bpf/xcp_router_user.c
@@ -0,0 +1,211 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2017-18 David Ahern <dsahern@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/bpf.h>
+#include <linux/if_link.h>
+#include <linux/limits.h>
+#include <net/if.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <libgen.h>
+
+#include "bpf/libbpf.h"
+#include <bpf/bpf.h>
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "bpf_util.h"
+
+
+struct per_port_states {
+    /*Number of bytes sent*/    
+    uint64_t B;
+    /*Number of on-goinhg flows*/
+    uint32_t N;
+    uint64_t Q;
+    /*Number of packets received during the control interval*/
+    uint64_t n;
+    /*Feedback rate of this router*/
+    uint64_t R;
+    uint32_t rtt_tot, rtt_a;
+};
+
+
+static void usage(const char *prog)
+{
+	fprintf(stderr,
+		"usage: %s [OPTS] interface-list\n"
+		"\nOPTS:\n"
+		"    -d    detach program\n"
+		"    -D    direct table lookups (skip fib rules)\n",
+		prog);
+}
+
+static int nr_cpus;
+static int map_fd, prog_fd;
+static struct bpf_object *obj;
+
+int states_init(struct per_port_states *states);
+int states_reset(struct per_port_states *states);
+int calc_rcp_rate(struct per_port_states *states);
+void on_alarm(int signum);
+
+int states_init(struct per_port_states *states)
+{
+  states->rtt_a = 200;
+  states->n = 200;
+  states->N = 200;
+  states->R = 200;
+  states->B = 450;
+  states->Q = 0;
+  return 0;
+}
+
+int states_reset(struct per_port_states *states)
+{
+  states->rtt_a = 200;
+  states->rtt_tot = 0;
+  states->n = 0;
+  states->N = 200;
+  states->R = 200;
+  states->B = 0;
+  states->Q = 0;
+  return 0;
+}
+
+int calc_rcp_rate(struct per_port_states *states)
+{
+    uint64_t S = states->rtt_a == 0 ? 2000 : 2000 - states->B/states->rtt_a;
+    states->rtt_a = states->n == 0 ? 200 : states->rtt_tot/states->n;
+    states->R = states->N == 0 ? 2000 : states->R + ((400 * states->rtt_a * S - 226 * states->Q)/(1000 * states->N));
+    printf("In calc_rcp_rate. B=%llu RTT_a=%u S=%llu Q=%llu N=%u %llu \n", states->B, states->rtt_a, S, states->Q, states->N, states->R);	
+    return 0;
+}
+
+void on_alarm(int signum)
+{
+    struct bpf_map *map;
+    struct per_port_states allstates[nr_cpus];
+    uint32_t key = 0;
+    struct per_port_states states;
+    
+    map = bpf_object__find_map_by_name(obj, "states_map");
+    map_fd = bpf_map__fd(map);
+    if (map_fd < 0) {
+            printf("states_map not found: %s\n", strerror(map_fd));
+            return;
+    }
+    
+    if (bpf_map_lookup_elem(map_fd, &key, allstates) < 0)
+            return;
+    
+    states = allstates[0];    
+    calc_rcp_rate(&states);    
+    states_reset(&states);
+    
+    if (bpf_map_update_elem(map_fd, &key, &states, BPF_ANY) != 0) {
+            fprintf(stderr, "states_map map update failed: %s\n", strerror(errno));
+            return;
+    }
+    
+    ualarm(states.rtt_a * 1000, 0);  // Reschedule alarm
+}
+
+int main(int argc, char **argv)
+{
+	struct bpf_prog_load_attr prog_load_attr = {
+		.prog_type	= BPF_PROG_TYPE_XDP,
+	};
+	const char *prog_name = "xcp_router";
+	struct bpf_program *prog;
+	char filename[PATH_MAX];
+
+	int opt;
+	int attach = 1;
+	int ret = 0;
+        struct bpf_map *map;
+        struct per_port_states states;
+        uint32_t key = 0;
+        
+	nr_cpus = bpf_num_possible_cpus();
+	printf("nr_cpus:%d\n\n", nr_cpus);
+        
+        
+        signal( SIGALRM, on_alarm ); // Install handler first,
+
+	while ((opt = getopt(argc, argv, ":dD")) != -1) {
+		switch (opt) {
+		case 'd':
+			attach = 0;
+			break;
+		default:
+			usage(basename(argv[0]));
+			return 1;
+		}
+	}
+
+	if (optind == argc) {
+		usage(basename(argv[0]));
+		return 1;
+	}
+
+	if (attach) {
+		snprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);
+		prog_load_attr.file = filename;
+
+		if (access(filename, O_RDONLY) < 0) {
+			printf("error accessing file %s: %s\n",
+				filename, strerror(errno));
+			return 1;
+		}
+		if (bpf_prog_load_xattr(&prog_load_attr, &obj, &prog_fd))
+			return 1;
+
+		prog = bpf_object__find_program_by_title(obj, prog_name);
+		prog_fd = bpf_program__fd(prog);
+		if (prog_fd < 0) {
+			printf("program not found: %s\n", strerror(prog_fd));
+			return 1;
+		}
+                
+                map = bpf_object__find_map_by_name(obj, "states_map");
+		map_fd = bpf_map__fd(map);
+		if (map_fd < 0) {
+			printf("states_map map not found: %s\n", strerror(map_fd));
+			return 1;
+		}
+                
+                if(bpf_map_lookup_elem(map_fd, &key, &states) < 0)
+                        return XDP_ABORTED;
+                
+                states_init(&states);
+                
+                if (bpf_map_update_elem(map_fd, &key, &states, BPF_ANY) != 0) {
+                        fprintf(stderr, "states_map map update failed: %s\n", strerror(errno));
+                        return XDP_ABORTED;
+                }
+                
+                ualarm(states.rtt_a * 1000, 0);               
+	}
+        
+        printf("Press ENTER key to Continue\n");  
+        getchar(); 
+        
+	return ret;
+}
