diff --git a/samples/bpf/Makefile b/samples/bpf/Makefile
index 36f9f41..b069d51 100644
--- a/samples/bpf/Makefile
+++ b/samples/bpf/Makefile
@@ -51,6 +51,7 @@ hostprogs-y += cpustat
 hostprogs-y += xdp_adjust_tail
 hostprogs-y += xdpsock
 hostprogs-y += xdp_fwd
+hostprogs-y += sail
 hostprogs-y += task_fd_query
 hostprogs-y += xdp_sample_pkts
 
@@ -107,6 +108,7 @@ cpustat-objs := bpf_load.o cpustat_user.o
 xdp_adjust_tail-objs := xdp_adjust_tail_user.o
 xdpsock-objs := xdpsock_user.o
 xdp_fwd-objs := xdp_fwd_user.o
+sail-objs := sail_user.o
 task_fd_query-objs := bpf_load.o task_fd_query_user.o $(TRACE_HELPERS)
 xdp_sample_pkts-objs := xdp_sample_pkts_user.o $(TRACE_HELPERS)
 
@@ -164,6 +166,7 @@ always += cpustat_kern.o
 always += xdp_adjust_tail_kern.o
 always += xdpsock_kern.o
 always += xdp_fwd_kern.o
+always += sail_kern.o
 always += task_fd_query_kern.o
 always += xdp_sample_pkts_kern.o
 
diff --git a/samples/bpf/sail.h b/samples/bpf/sail.h
new file mode 100644
index 0000000..893da97
--- /dev/null
+++ b/samples/bpf/sail.h
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019-20 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+/*The length of N16, P16 and C16 is 2^16*/
+#define LEVEL16_SIZE 65536
+
+/*Length of C24.*/
+#define C24_SIZE 1048576
+
+/*chunk size is 2^8*/
+#define CHUNK_SIZE 256
+
+/*Total number of chunks preallocated for level 24 and 32*/
+#define NUM_CHUNKS 16384
+
+/*Calculates the number of bits set to 1*/
+#define POPCNT(X) (hweight64(X))
+
+/*POPCNT of left-most N bits of X*/
+#define POPCNT_OFF(X, N) (hweight64(((1ULL << (N)) - 1) & (X)))
+
+struct chunk {
+	/*256-bit bitmap. Here i-th bit (from LSB) is set to 1 if C24[i] > 0 */
+	__u64 bitmap[4];
+	/*
+	 * Index to C24 where chunk is started. A chunk corresponds
+	 * to 256 elements. Instead of having just one start index for the
+	 * whole chunk, we divide the chunk into 4 parts and save start
+	 * index for each part.
+	 */
+	__u64 start_index[4];
+};
+
+struct sail {
+	/*default next-hop (Level 0)*/
+	char	def_nh;
+
+	/*Level 16*/
+	char *N16;
+	char *P16;
+	__u16 *C16;
+
+	/*Level 24*/
+	char *N24;
+	char *P24;
+	struct chunk *CK24;
+	__u32 *C24;
+	__u32 cnk24_count;/*Number of chunks in level 24*/
+
+	/*Level 32*/
+	char *N32;
+	char *P32;
+	__u32 cnk32_count;/*Number of chunks in level 32*/
+};
diff --git a/samples/bpf/sail_kern.c b/samples/bpf/sail_kern.c
new file mode 100644
index 0000000..003b953
--- /dev/null
+++ b/samples/bpf/sail_kern.c
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019-20 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+#define KBUILD_MODNAME "foo"
+#include <uapi/linux/bpf.h>
+#include <linux/in.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+
+#include "bpf_helpers.h"
+#include "sail.h"
+
+#define bpf_printk(fmt, ...)					\
+({								\
+	       char ____fmt[] = fmt;				\
+	       bpf_trace_printk(____fmt, sizeof(____fmt),	\
+				##__VA_ARGS__);			\
+})
+
+struct pkthdr {
+        /*Ethernet header starts here. */
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	__be16		h_proto;		/* packet type ID field	*/
+        
+        /*IP header starts here. */
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__be16	tot_len;
+	__be16	id;
+	__be16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__sum16	check_ip;
+	__be32	saddr;
+	__be32	daddr;
+};
+
+struct per_port_states {
+    /*Number of bytes sent*/    
+    __u64 B;
+    __u64 Q;
+    /*Number of packets received during the control interval*/
+    __u64 n;
+    /*Feedback rate of this router*/
+    __u64 R;
+    __u32 rtt_tot, rtt_a;
+};
+
+struct bpf_map_def SEC("maps") states_map = {
+	.type		= BPF_MAP_TYPE_PERCPU_ARRAY,
+	.key_size	= sizeof(__u32),
+	.value_size	= sizeof(struct per_port_states),
+	.max_entries	= 1,
+};
+
+struct bpf_map_def SEC("maps") sail_map = {
+	.type		= BPF_MAP_TYPE_ARRAY,
+	.key_size	= sizeof(__u32),
+	.value_size	= sizeof(struct sail),
+	.max_entries	= 1,
+};
+
+static int sail_lookup(const struct sail *s, const __be32 dest)
+{
+	const u32 key = ntohl(dest);
+	u16 n16_idx;/*Index to N16 and C16*/
+	u64 n24_idx;/*Index to N24*/
+	u32 ck24_idx;/*Index to CK24*/
+	u64 ck24_off;/*Offset inside a chunk*/
+	u64 c24_idx;/*Index to C24*/
+	u64 n32_idx;/*Index to N32*/
+	u8 part_idx, part_off;
+
+	/*extract 16 bits from LSB*/
+	n16_idx = key >> 16;
+	if (unlikely(!s->N16))
+		return s->def_nh;
+
+	if (likely(s->N16[n16_idx] != 0))
+		return s->N16[n16_idx];
+
+	/*Check if there is a longer prefix; if yes, extract bit 17~24
+	 *  and calculate index to N24
+	 */
+	if (likely(s->C16[n16_idx] != 0)) {
+		ck24_idx = s->C16[n16_idx] - 1;
+		ck24_off = (key & 65280) >> 8;
+		n24_idx = ck24_idx * CHUNK_SIZE + ck24_off;
+	} else {
+		return s->def_nh;
+	}
+
+	/*Find corresponding next-hop in level 24*/
+	if (likely(s->N24[n24_idx] != 0))
+		return s->N24[n24_idx];
+
+	/*Check if there is a longer prefix; if yes, extract 8 bits
+	 * from MSB and calculate index to N32
+	 */
+	part_idx = ck24_off / 64;
+	part_off = ck24_off % 64;
+	if (likely(s->CK24[ck24_idx].bitmap[part_idx] & (1ULL << part_off))) {
+		c24_idx = s->CK24[ck24_idx].start_index[part_idx] +
+			POPCNT_OFF(s->CK24[ck24_idx].bitmap[part_idx], part_off);
+		n32_idx = (s->C24[c24_idx] - 1) * CHUNK_SIZE + (key & 255);
+	} else {
+		return s->def_nh;
+	}
+
+	if (likely(s->N32[n32_idx] != 0))
+		return s->N32[n32_idx];
+        
+        return s->def_nh;
+}
+
+/*
+ * sudo ./bpftool prog show
+ * sudo ./bpftool prog dump xlated id 4
+ * sudo ./bpftool prog dump jited id 4
+ */
+
+SEC("sail_lookup")
+int xcp_router_prog(struct xdp_md *ctx)
+{
+    void *data_end = (void *)(long)ctx->data_end;
+    void *data = (void *)(long)ctx->data;
+    int len = data_end - data;
+    struct pkthdr *ph = data;
+    struct sail *s;
+    __u32 key = 0;
+    int ifindex;
+    
+    
+    if (data + 67 > data_end)
+            return XDP_DROP;
+    
+    if (unlikely(ph->version != 4))
+        return XDP_DROP;
+
+    /* sudo cat /sys/kernel/debug/tracing/trace_pipe to see the BPF debug output */
+    bpf_printk("Hello world %d \n", len);/* DEBUG ONLY */
+
+    s = bpf_map_lookup_elem(&sail_map, &key);
+    if (!s)
+            return XDP_ABORTED;
+    
+    sail_lookup(s, ph->daddr);
+   
+    return XDP_PASS;
+}
+
+char _license[] SEC("license") = "GPL";
diff --git a/samples/bpf/sail_user.c b/samples/bpf/sail_user.c
new file mode 100644
index 0000000..78dbefe
--- /dev/null
+++ b/samples/bpf/sail_user.c
@@ -0,0 +1,1211 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019-20 MD Iftakharul Islam (Tamim) <mislam4@kent.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/bpf.h>
+#include <linux/if_link.h>
+#include <linux/limits.h>
+#include <net/if.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <libgen.h>
+
+#include "bpf/libbpf.h"
+#include <bpf/bpf.h>
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "bpf_util.h"
+#include "sail.h"
+
+#define C 40*1024*1024*1024
+#define ALPHA .4
+#define BETA .6
+#define Q_MAX 20000
+#define R_INIT 10 * 1024 * 1024
+#define RTT_A_INIT 200
+#define NUM_PORTS 64
+
+/*Calculates the number of bits set to 1*/
+#define POPCOUNT(X) (__builtin_popcount(X))
+
+/*POPCOUNT of left-most N bits of X*/
+#define POPCOUNT_OFF(X, N) (__builtin_popcount(((1ULL << (N)) - 1) & (X)))
+
+/*Calculate index to C24 from CK26 chunk and chunk offset */
+static __u64 calc_c24_idx(struct chunk c, __u32 cnk_off)
+{
+	char part_idx, part_off;
+
+	part_idx = cnk_off / 64;
+	part_off = cnk_off % 64;
+
+	return c.start_index[part_idx] +
+		POPCOUNT_OFF(c.bitmap[part_idx], part_off);
+}
+
+/* Insert a new chunk to N24 and P24 at index chunk_id-1*/
+static int N24_insert(struct sail *s, __u16 chunk_id)
+{
+	long long m;
+
+	if (chunk_id > (s->cnk24_count + 1) || chunk_id < 1) {
+		printf("Invalid chunk_id for level 26");
+		return -EINVAL;
+	}
+
+	if (s->cnk24_count >= NUM_CHUNKS) {
+		printf("Cannot insert a chunk. The chunk array is full");
+		return -EINVAL;
+	}
+
+	/*shift each element one step right to make
+	 *space for the new one
+	 */
+	m = (long long)s->cnk24_count * CHUNK_SIZE - 1;
+	for (; m >= (chunk_id - 1) * CHUNK_SIZE; m--) {
+		s->N24[m + CHUNK_SIZE] = s->N24[m];
+		s->P24[m + CHUNK_SIZE] = s->P24[m];
+	}
+
+	/*Reset the newly created chunk*/
+	m = (chunk_id - 1) * CHUNK_SIZE;
+	for (; m < chunk_id * CHUNK_SIZE; m++) {
+		s->N24[m] = 0;
+		s->P24[m] = 0;
+	}
+	return 0;
+}
+
+/* Insert a new chunk to CK24 at index chunk_id-1*/
+static int CK24_insert(struct sail *s, __u16 chunk_id)
+{
+	long long m;
+
+	if (chunk_id > (s->cnk24_count + 1) || chunk_id < 1) {
+		printf("Invalid chunk_id for level 26");
+		return -EINVAL;
+	}
+
+	if (s->cnk24_count >= NUM_CHUNKS) {
+		printf("Cannot insert a chunk. The chunk array is full");
+		return -EINVAL;
+	}
+
+	/*shift each chunk one step right to make
+	 *space for the new one
+	 */
+	m = (long long)s->cnk24_count - 1;
+	for (; m >= (chunk_id - 1); m--)
+		s->CK24[m + 1] = s->CK24[m];
+
+	/*Reset the newly created empty chunk*/
+	for (m = 0; m < 4; m++) {
+		s->CK24[chunk_id - 1].bitmap[m] = 0;
+		s->CK24[chunk_id - 1].start_index[m] = 0;
+	}
+	return 0;
+}
+
+/* Insert a new chunk to level 24 at chunk_id-1. Note that Chunk ID
+ * starts from 1, not 0
+ */
+static int chunk24_insert(struct sail *s, __u16 chunk_id)
+{
+	int err = 0;
+
+	err = N24_insert(s, chunk_id);
+	if (!err)
+		err = CK24_insert(s, chunk_id);
+	if (!err)
+		++s->cnk24_count;
+	else
+		printf("Error in level 24 insertion");
+	return err;
+}
+
+/* Insert a new chunk to level 32 at chunk_id-1. Note that Chunk ID
+ * starts from 1, not 0
+ */
+static int chunk32_insert(struct sail *s, __u32 chunk_id)
+{
+	long long m;
+
+	if (chunk_id > (s->cnk32_count + 1) || chunk_id < 1) {
+		printf("Invalid chunk_id for level 32");
+		return -EINVAL;
+	}
+
+	if (s->cnk32_count >= NUM_CHUNKS) {
+		printf("Cannot insert a new chunk. The chunk array is full");
+		return -EINVAL;
+	}
+
+	/*shift each element one step right to make
+	 *space for the new one
+	 */
+	m = (long long)s->cnk32_count * CHUNK_SIZE - 1;
+	for (; m >= (chunk_id - 1) * CHUNK_SIZE; m--) {
+		s->N32[m + CHUNK_SIZE] = s->N32[m];
+		s->P32[m + CHUNK_SIZE] = s->P32[m];
+	}
+
+	/*Reset the newly created empty chunk*/
+	m = (chunk_id - 1) * CHUNK_SIZE;
+	for (; m < chunk_id * CHUNK_SIZE; m++) {
+		s->N32[m] = 0;
+		s->P32[m] = 0;
+	}
+
+	++s->cnk32_count;
+	return 0;
+}
+
+static int N24_delete(struct sail *s, __u16 chunk_id)
+{
+	long long m;
+	__u64 end_idx;
+
+	if (chunk_id > s->cnk24_count) {
+		printf("Invalid chunk_id to level 26");
+		return -EINVAL;
+	}
+
+	if (chunk_id < s->cnk24_count) {
+		/*shift each chunk one step left*/
+		m = (long long)chunk_id * CHUNK_SIZE;
+		end_idx = s->cnk24_count * CHUNK_SIZE - 1;
+		for (; m <= end_idx; m++) {
+			s->N24[m - CHUNK_SIZE] = s->N24[m];
+			s->P24[m - CHUNK_SIZE] = s->P24[m];
+		}
+	}
+
+	/*Reset the the last chunk*/
+	end_idx = s->cnk24_count * CHUNK_SIZE - 1;
+	m = (s->cnk24_count - 1) * CHUNK_SIZE;
+	for (; m <= end_idx; m++) {
+		s->N24[m] = 0;
+		s->P24[m] = 0;
+	}
+
+	return 0;
+}
+
+static int CK24_delete(struct sail *s, __u16 chunk_id)
+{
+	long long m;
+
+	if (chunk_id > s->cnk24_count) {
+		printf("Invalid chunk_id to level 24");
+		return -EINVAL;
+	}
+
+	if (chunk_id < s->cnk24_count) {
+		/*shift each chunk one step left*/
+		m = (long long)chunk_id;
+		for (; m <= s->cnk24_count - 1; m++)
+			s->CK24[m - 1] = s->CK24[m];
+	}
+
+	/*Reset the the last chunk*/
+	for (m = 0; m < 4; m++) {
+		s->CK24[s->cnk24_count - 1].start_index[m] = 0;
+		s->CK24[s->cnk24_count - 1].bitmap[m] = 0;
+	}
+
+	return 0;
+}
+
+static int chunk24_delete(struct sail *s, __u16 chunk_id)
+{
+	N24_delete(s, chunk_id);
+	CK24_delete(s, chunk_id);
+	--s->cnk24_count;
+	return 0;
+}
+
+static int chunk32_delete(struct sail *s, __u32 chunk_id)
+{
+	long long m;
+	__u64 end_idx;
+
+	if (chunk_id > s->cnk32_count) {
+		printf("Invalid chunk_id to level 32");
+		return -EINVAL;
+	}
+
+	if (chunk_id < s->cnk32_count) {
+		/*shift each chunk one step left*/
+		m = (long long)chunk_id * CHUNK_SIZE;
+		end_idx = s->cnk32_count * CHUNK_SIZE - 1;
+		for (; m <= end_idx; m++) {
+			s->N32[m - CHUNK_SIZE] = s->N32[m];
+			s->P32[m - CHUNK_SIZE] = s->P32[m];
+		}
+	}
+
+	/*Reset the the last chunk*/
+	end_idx = s->cnk32_count * CHUNK_SIZE - 1;
+	m = (s->cnk32_count - 1) * CHUNK_SIZE;
+	for (; m <= end_idx; m++) {
+		s->N32[m] = 0;
+		s->P32[m] = 0;
+	}
+
+	--s->cnk32_count;
+	return 0;
+}
+
+/*Calculate the chunk ID for level 24 based on C16*/
+static __u16 calc_ckid24_from_C16(__u16 *c16, __u32 c16_size, __u16 idx16)
+{
+	long long i;
+
+	if (idx16 >= c16_size) {
+		printf("Index needs to be smaller than arr_size");
+		return 0;
+	}
+
+	/*Find the first chunk ID to the left and increment that by 1*/
+	for (i = (long long)idx16 - 1; i >= 0; i--) {
+		if (c16[i] > 0)
+			return c16[i] + 1;
+	}
+
+	/*If there is no chunk to the left, then this is the first chunk*/
+	return 1;
+}
+
+/*Update C16 based on the newly inserted chunk*/
+static int update_C16(__u16 *c16, __u32 c16_size,
+		      __u16 idx16, __u16 chunk_id)
+{
+	long long i;
+
+	if (idx16 >= c16_size) {
+		printf("Invalid index");
+		return -EINVAL;
+	}
+
+	c16[idx16] = chunk_id;
+
+	/* Increment chunk ID to the right */
+	for (i = idx16 + 1; i < c16_size; i++) {
+		if (c16[i] > 0)
+			c16[i]++;
+	}
+
+	return 0;
+}
+
+/*Remove Chunk ID for level 16*/
+static int C16_remove_chunkid(__u16 *c16, __u32 c16_size, __u16 chunk_id)
+{
+	long long i;
+	bool found = false;
+
+	/*Check if the chunk ID already exists*/
+	for (i = 0; i < c16_size; i++) {
+		if (found && c16[i] > 0) {
+			c16[i]--;
+		} else if (c16[i] == chunk_id) {
+			c16[i] = 0;
+			found = true;
+		}
+	}
+
+	return 0;
+}
+
+static int C24_remove_chunkid(struct sail *s, __u16 cnk_idx, __u64 cnk_off)
+{
+	long long i;
+	bool found = false;
+	__u32 chunk_id;
+	char part_idx, part_off;
+
+	part_idx = cnk_off / 64;
+	part_off = cnk_off % 64;
+
+	chunk_id = s->C24[calc_c24_idx(s->CK24[cnk_idx], cnk_off)];
+	s->CK24[cnk_idx].bitmap[part_idx] &= ~(1ULL << part_off);
+
+	for (i = 0; i < C24_SIZE; i++) {
+		if (s->C24[i] == chunk_id)
+			found = true;
+		else if (found && s->C24[i] > 0)
+			s->C24[i - 1] = s->C24[i];
+		else if (found && !s->C24[i])
+			break;
+	}
+
+	return 0;
+}
+
+ /* Check if a chunk in level 32 is being unused */
+static bool is_N32_chunk_unused(char *nh, __u32 chunk_id)
+{
+	long long i;
+	long long start_index, end_index;
+
+	if (chunk_id < 1) {
+		printf("Invalid chunk ID");
+		return -EINVAL;
+	}
+
+	start_index = (long long)(chunk_id - 1) * CHUNK_SIZE;
+	end_index = (long long)chunk_id * CHUNK_SIZE - 1;
+	for (i = start_index; i <= end_index; i++) {
+		/*The chunk is being used*/
+		if (nh[i] > 0)
+			return false;
+	}
+
+	return true;
+}
+
+ /* Check if a chunk in level 24 is being unused*/
+static bool is_CK24_N24_chunk_unused(char *nh, struct chunk *ck, __u16 chunk_id)
+{
+	long long i;
+	long long start_index, end_index;
+
+	if (chunk_id < 1) {
+		printf("Invalid chunk ID");
+		return -EINVAL;
+	}
+
+	start_index = (long long)(chunk_id - 1) * CHUNK_SIZE;
+	end_index = (long long)chunk_id * CHUNK_SIZE - 1;
+	for (i = start_index; i <= end_index; i++) {
+		/*The chunk is being used*/
+		if (nh[i] > 0)
+			return false;
+	}
+
+	if (ck->bitmap[0] || ck->bitmap[1] || ck->bitmap[2] || ck->bitmap[3])
+		return false;
+
+	return true;
+}
+
+/*Calculate the chunk ID for level 32 based on CK24 and C24*/
+static __u32 calc_ckid32_from_ck24(struct chunk *ck24,
+				 __u32 ck24_idx, __u32 ck24_off, __u32 *c24)
+{
+	long long i, j;
+	long long index = 0;
+	char part_idx, part_off;
+	struct chunk c;
+
+	part_idx = ck24_off / 64;
+	part_off = ck24_off % 64;
+	c = ck24[ck24_idx];
+
+	/*find the index to C24 where previous chunk ID would be found*/
+	if (c.bitmap[part_idx]) {
+		index = c.start_index[part_idx] +
+		    POPCOUNT_OFF(c.bitmap[part_idx], part_off) - 1;
+		if (index >= 0)
+			goto index_found;
+	}
+
+	j = part_idx - 1;
+	for (i = (long long)ck24_idx; i >= 0; i--) {
+		for (; j >= 0; j--) {
+			if (ck24[i].bitmap[j]) {
+				index = ck24[i].start_index[j] +
+					POPCOUNT(ck24[i].bitmap[j]) - 1;
+				goto index_found;
+			}
+		}
+		j = 3;
+	}
+
+	/*If there is no chunk to the left, then this is the first chunk*/
+	return 1;
+index_found:
+	if (index >= (C24_SIZE - 1)) {
+		printf("CK24 array is full. Cannot insert");
+		return 0;
+	} else if (c24[index] <= 0) {
+		printf("Invalid chunk ID");
+		return 0;
+	} else {
+		return c24[index] + 1;
+	}
+}
+
+/*Update CK24 and C24 based on the newly inserted chunk*/
+static int update_ck24_c24(struct chunk *ck24, __u32 ck24_idx, __u32 ck24_off,
+			   __u32 *c24, __u32 cnk24_count, __u32 chunk_id)
+{
+	long long i, j;
+	__u64 index = 0;
+	char part_idx, part_off;
+
+	part_idx = ck24_off / 64;
+	part_off = ck24_off % 64;
+
+	if (ck24[ck24_idx].bitmap[part_idx] & (1ULL << part_off)) {
+		printf("Error: bitmap is already set");
+		return -EINVAL;
+	}
+
+	/*find the index where Chunk ID should be copied to*/
+	if (ck24[ck24_idx].bitmap[part_idx]) {
+		index = ck24[ck24_idx].start_index[part_idx] +
+			POPCOUNT_OFF(ck24[ck24_idx].bitmap[part_idx], part_off);
+		goto index_found;
+	}
+
+	/*Find a chunk to the left which is not empty*/
+	j = part_idx - 1;
+	for (i = (long long)ck24_idx; i >= 0; i--) {
+		for (; j >= 0; j--) {
+			if (ck24[i].bitmap[j]) {
+				index = ck24[i].start_index[j] +
+					POPCOUNT(ck24[i].bitmap[j]);
+				goto index_found;
+			}
+		}
+		j = 3;
+	}
+
+index_found:
+	/* Move each element one step to the right to create a space for
+	 * the new element. Also increment each element by 1
+	 */
+	for (i = C24_SIZE - 2 ; i >= (long long)index; i--)
+		c24[i + 1] = (c24[i] > 0) ? c24[i] + 1 : c24[i];
+	/*Set the new Chunk ID*/
+	c24[index] = chunk_id;
+
+	/*This is the first element of this chunk*/
+	if (!ck24[ck24_idx].bitmap[part_idx])
+		ck24[ck24_idx].start_index[part_idx] = index;
+
+	ck24[ck24_idx].bitmap[part_idx] |= (1ULL << part_off);
+
+	/*Update offset of the chunks to the right*/
+	j = part_idx + 1;
+	for (i = (long long)ck24_idx; i < cnk24_count; i++) {
+		for (; j < 4; j++) {
+			if (ck24[i].bitmap[j])
+				ck24[i].start_index[j]++;
+		}
+		j = 0;
+	}
+
+	return 0;
+}
+
+/*Push nodes from level to level 32*/
+static bool push_frm_24(struct sail *s, __u64 n24_idx, __u64 c24_idx)
+{
+    bool pushed = false;
+    bool is_push_needed = false;
+    __u64 n32_idx;
+    int j;
+
+    if(s->C24[c24_idx] == 0){
+        printf("C24[i]=NULL in from_24_to_32 !!!!!!!!");
+        return pushed;
+    }
+    
+    n32_idx = (s->C24[c24_idx] - 1) * CHUNK_SIZE;
+
+    /*Longer prefix exist in level 24*/
+    for (j = 0; j < 256; j++) {
+        if (s->N32[n32_idx + j] > 0) {
+            is_push_needed = true;
+            break;
+        }
+    }
+
+    if(!is_push_needed)
+        return pushed;
+
+    for (j = 0; j < 256; j++) {
+        if (s->P24[n24_idx] > s->P32[n32_idx + j]) {
+            s->N32[n32_idx + j] = s->N24[n24_idx];
+            s->P32[n32_idx + j] = s->P24[n24_idx];
+            pushed = true;
+        }
+    }
+
+    if (pushed) {
+        s->N24[n24_idx] = 0;
+        s->P24[n24_idx] = 0;
+    }
+        
+    return pushed;
+}
+
+/*Push nodes from level 16 to level 24 or level 32*/
+static bool push_frm_16(struct sail *s, __u16 n16_idx)
+{
+    bool pushed = false;
+    bool is_push_needed = false;
+    int n24_idx;
+    int j;
+    __u64 c24_idx;/*Index to C24*/
+    __u32 ck24_idx;/*Index to CK24*/
+    __u64 ck24_off;/*offset inside a chunk*/
+    char part_idx, part_off;
+
+    if(s->C16[n16_idx] == 0)
+        return pushed;
+    
+    n24_idx = (s->C16[n16_idx] - 1) * CHUNK_SIZE;
+
+    /*Longer prefix exist in level 24*/
+    for (j = 0; j < 256; j++) {
+        if (s->N24[n24_idx + j] > 0) {
+            is_push_needed = true;
+            break;
+        }
+    }
+
+    if(!is_push_needed)
+        return pushed;
+
+    for (j = 0; j < 256; j++) {
+        if (s->P16[n16_idx] > s->P24[n24_idx + j]) {
+            s->N24[n24_idx + j] = s->N16[n16_idx];
+            s->P24[n24_idx + j] = s->P16[n16_idx];
+            pushed = true;
+        }
+
+        /*After pushing it to level 24, need to check if can be pushed to level 32*/
+	ck24_idx = s->C16[n16_idx] - 1;
+	ck24_off = j;     
+	c24_idx = calc_c24_idx(s->CK24[ck24_idx], ck24_off);
+	part_idx = ck24_off / 64;
+	part_off = ck24_off % 64;
+        
+        /*There is a chunk in level 32*/
+        if(s->CK24[ck24_idx].bitmap[part_idx] & (1ULL << part_off))
+            push_frm_24(s, n24_idx + j, c24_idx);
+    }
+
+    if (pushed) {
+        s->N16[n16_idx] = 0;
+        s->P16[n16_idx] = 0;
+    }
+        
+    return pushed;
+}
+
+/*This function should be called after holding a spin lock*/
+int sail_insert(struct sail *s, __u32 key, char prefix_len,
+		int netdev_index)
+{
+	int i;
+	char *n16, *p16, *n24, *p24, *n32, *p32;
+	__u16 *c16;
+	__u32 *c24;
+	struct chunk *ck24;
+	__u16 chunk_id;
+	__u16 n16_idx;/*Index to N16, P16 and C16*/
+	__u64 n24_idx;/*Index to N24 and P24*/
+	__u64 c24_idx;/*Index to C24*/
+	__u32 ck24_idx;/*Index to CK24*/
+	__u64 ck24_off;/*offset inside a chunk*/
+	char part_idx, part_off;
+	__u64 n32_idx;/*Index to N32 and P32*/
+	__u32 num_leafs;/*Number of leafs need to be inserted for this prefix*/
+	int err = 0;
+
+	/* Default route */
+	if (prefix_len == 0) {
+		s->def_nh = netdev_index;
+		goto finish;
+	}
+
+	/* Preallocate all the arrays at once*/
+	if (!s->N16) {
+		n16 = calloc(LEVEL16_SIZE, sizeof(*n16));
+		p16 = calloc(LEVEL16_SIZE, sizeof(*p16));
+		c16 = calloc(LEVEL16_SIZE, sizeof(*c16));
+		n24 = calloc(NUM_CHUNKS * CHUNK_SIZE, sizeof(*n24));
+		p24 = calloc(NUM_CHUNKS * CHUNK_SIZE, sizeof(*p24));
+		ck24 = calloc(NUM_CHUNKS, sizeof(*ck24));
+		c24 = calloc(C24_SIZE, sizeof(*c24));
+		n32 = calloc(NUM_CHUNKS * CHUNK_SIZE, sizeof(*n32));
+		p32 = calloc(NUM_CHUNKS * CHUNK_SIZE, sizeof(*p32));
+
+		if (!n16 || !c16 || !p16 || !n24 || !p24 || !ck24 ||
+		    !c24 || !n32 || !p32) {
+			free(n16);
+			free(c16);
+			free(p16);
+			free(n24);
+			free(p24);
+			free(ck24);
+			free(c24);
+			free(n32);
+			free(p32);
+			printf("Out of memory while preallocating  SAIL");
+			goto error;
+		}
+
+		s->N16 = n16;
+		s->P16 = p16;
+		s->C16 = c16;
+		s->N24 = n24;
+		s->P24 = p24;
+		s->CK24 = ck24;
+		s->C24 = c24;
+		s->N32 = n32;
+		s->P32 = p32;
+	}
+
+	/*Eextract 16 bits from LSB.*/
+	n16_idx = key >> 16;
+
+	if (prefix_len <= 16) {
+	    	/*Check the longest prefix on the path.*/
+
+		/*All the leafs in level 1~16 will be stored in level 16.*/
+		num_leafs = 1U << (16 - prefix_len);
+		for (i = 0; i < num_leafs; i++) {
+			/*Longer prefix exists*/
+			if (s->P16[n16_idx + i] > prefix_len)
+				continue;
+			s->N16[n16_idx + i] = netdev_index;
+			s->P16[n16_idx + i] = prefix_len;
+                        push_frm_16(s, n16_idx + i);
+		}
+		goto finish;
+	}
+
+	/* The length of the prefix is 21~32. So need to check if there is a
+	 * chunk for this prefix in level 24. C16[..] = 0 indicates that there
+	 * is no chunk, so need to insert one. The insertion works as
+	 * following:
+	 * 1. Calculate the chunk ID to level 24 from C16. The Chunk ID
+	 * indicates where the new chunk should be inserted.
+	 * 2. Insert a new chunk in level 24
+	 * 3. Update the C16[] based on the newly inserted chunk
+	 */
+	if (s->C16[n16_idx] == 0) {
+		/*Step 1*/
+		chunk_id = calc_ckid24_from_C16(s->C16, LEVEL16_SIZE, n16_idx);
+		if (!chunk_id)
+			goto error;
+		/*Step 2*/
+		err = chunk24_insert(s, chunk_id);
+		if (err)
+			goto error;
+		/*Step 3*/
+		err = update_C16(s->C16, LEVEL16_SIZE, n16_idx, chunk_id);
+		if (err)
+			goto error;
+	}
+
+	/*Extract bit 17~24 and calculate index to level 24*/
+	n24_idx = (s->C16[n16_idx] - 1) * CHUNK_SIZE + ((key & 65280) >> 8);
+	ck24_idx = s->C16[n16_idx] - 1;
+	ck24_off = (key & 65280) >> 8;
+
+	if (prefix_len <= 24) {
+		/*All the leafs in level 17~24 will be stored in level 24.*/
+		num_leafs = 1U << (24 - prefix_len);
+		for (i = 0; i < num_leafs; i++) {
+			/*Longer prefix exists*/
+			if (s->P24[n24_idx + i] > prefix_len)
+				continue;
+			s->N24[n24_idx + i] = netdev_index;
+			s->P24[n24_idx + i] = prefix_len;
+                        /*There is a chunk in level 32*/
+                        if(s->CK24[ck24_idx].bitmap[part_idx] & (1ULL << part_off))
+                            push_frm_24(s, n24_idx + i, c24_idx);
+		}
+                
+                /*This node in level 16 also should be pushed to level 24*/
+                if(s->N16[n16_idx] != 0)
+                    push_frm_16(s, n16_idx);
+                
+		goto finish;
+	}       
+
+	part_idx = ck24_off / 64;
+	part_off = ck24_off % 64;
+	/* The length of the prefix is 25~32, but there is no chunk for
+	 * this prefix in level 32. So need to insert a new one.
+	 * The insertion works as following:
+	 * 1. Calculate the chunk ID to level 32 from CK24 and C24. The
+	 * Chunk ID indicates where the new chunk should be inserted.
+	 * 2. Insert a new chunk in level 32
+	 * 3. Update the CK24 and C24 based on the newly inserted chunk
+	 */
+	if (!(s->CK24[ck24_idx].bitmap[part_idx] & (1ULL << part_off))) {
+		/*Step 1*/
+		chunk_id = calc_ckid32_from_ck24(s->CK24, ck24_idx,
+						 ck24_off, s->C24);
+		if (!chunk_id)
+			goto error;
+		/*Step 2*/
+		err = chunk32_insert(s, chunk_id);
+		if (err)
+			goto error;
+		/*Step 3*/
+		err = update_ck24_c24(s->CK24, ck24_idx, ck24_off,
+				      s->C24, s->cnk24_count, chunk_id);
+		if (err)
+			goto error;
+	}
+
+	c24_idx = calc_c24_idx(s->CK24[ck24_idx], ck24_off);
+	/*Extract 8 bit from MSB and calculate index to level 32*/
+	n32_idx = (s->C24[c24_idx] - 1) * CHUNK_SIZE + (key & 255);
+
+	if (prefix_len <= 32) {
+		/*All the leafs in level 25~32 will be stored in level 32.*/
+		num_leafs = 1U << (32 - prefix_len);
+		for (i = 0; i < num_leafs; i++) {
+			/*Longer prefix exists*/
+			if (s->P32[n32_idx + i] > prefix_len)
+				continue;
+			s->N32[n32_idx + i] = netdev_index;
+			s->P32[n32_idx + i] = prefix_len;
+		}
+                
+                /*This node in level 24 also should be pushed to level 32*/
+                if(s->N24[n24_idx] != 0)
+                    push_frm_24(s, n24_idx, c24_idx);
+                
+                /*This node in level 16 also need to push up*/
+                if(s->N16[n16_idx] != 0)
+                    push_frm_16(s, n16_idx);
+		goto finish;
+	}
+
+error:
+	printf("Something went wrong in route insertion");
+finish:
+	return err;
+}
+
+//int sail_delete(struct sail *s, u32 key, u8 prefix_len)
+//{
+//	int i;
+//	u32 n16_idx;/*Index to N16, P16 and C16*/
+//	u64 n24_idx;/*Index to level N24 and P24*/
+//	u16 ck24_idx;/*Index to CK24*/
+//	u64 ck24_off;/*Offset inside chunk in level 24*/
+//	u64 n32_idx;/*Index to level N32 and P32*/
+//	u32 consecutive_leafs;
+//	int err = 0;
+//	u32 chunkid_level32;
+//	u8 part_idx, part_off;
+//
+//	spin_lock(&s->lock);
+//
+//	/* Simply ignore */
+//	if (prefix_len == 0 || !s->N16)
+//		goto error;
+//
+//	/*Eextract 16 bits from LSB.*/
+//	n16_idx = key >> 16;
+//
+//	if (prefix_len <= 16) {
+//		/*Level pushing*/
+//		consecutive_leafs = 1U << (16 - prefix_len);
+//		for (i = 0; i < consecutive_leafs; i++) {
+//			/*Prefix len doesn't match*/
+//			if (s->P16[n16_idx + i] != prefix_len)
+//				continue;
+//			s->N16[n16_idx + i] = 0;
+//			s->P16[n16_idx + i] = 0;
+//		}
+//		goto finish;
+//	}
+//
+//	/* The prefix_len is 17~32 but no chunk for the prefix*/
+//	if (s->C16[n16_idx] == 0)
+//		goto error;
+//
+//	ck24_idx = s->C16[n16_idx] - 1;
+//	ck24_off = (key & 65280) >> 8;/*Extract bit 17~24 from the prefix*/
+//	n24_idx = ck24_idx * CHUNK_SIZE + ck24_off;
+//
+//	if (prefix_len <= 24) {
+//		/*Level pushing*/
+//		consecutive_leafs = 1U << (24 - prefix_len);
+//		for (i = 0; i < consecutive_leafs; i++) {
+//			/*Prefix len doesn't match*/
+//			if (s->P24[n24_idx + i] != prefix_len)
+//				continue;
+//			s->N24[n24_idx + i] = 0;
+//			s->P24[n24_idx + i] = 0;
+//		}
+//		if (is_CK24_N24_chunk_unused(s->N24, &s->CK24[ck24_idx],
+//					     s->C16[n16_idx])) {
+//			chunk24_delete(s, s->C16[n16_idx]);
+//			C16_remove_chunkid(s->C16, LEVEL16_SIZE,
+//					   s->C16[n16_idx]);
+//		}
+//		goto finish;
+//	}
+//
+//	part_idx = ck24_off / 64;
+//	part_off = ck24_off % 64;
+//	/* The prefix_len is 25~32. but no chunk for the prefix */
+//	if (!(s->CK24[ck24_idx].bitmap[part_idx] & (1ULL << part_off)))
+//		goto error;
+//
+//	chunkid_level32 = s->C24[calc_c24_idx(s->CK24[ck24_idx], ck24_off)];
+//
+//	/*Extract 8 bit from MSB and calculate index to level 32*/
+//	n32_idx = (chunkid_level32 - 1) * CHUNK_SIZE + (key & 255);
+//
+//	if (prefix_len <= 32) {
+//		/*Level pushing*/
+//		consecutive_leafs = 1U << (32 - prefix_len);
+//
+//		for (i = 0; i < consecutive_leafs; i++) {
+//			/*Prefix len doesn't match*/
+//			if (s->P32[n32_idx + i] != prefix_len)
+//				continue;
+//			s->N32[n32_idx + i] = 0;
+//			s->P32[n32_idx + i] = 0;
+//		}
+//		if (is_N32_chunk_unused(s->N32, chunkid_level32)) {
+//			chunk32_delete(s, chunkid_level32);
+//			C24_remove_chunkid(s, ck24_idx, ck24_off);
+//		}
+//		goto finish;
+//	}
+//
+///*The prefix was not found*/
+//error:
+//	err = -ENOENT;
+//finish:
+//	spin_unlock(&s->lock);
+//	return err;
+//}
+//
+//int sail_flush(struct sail *s)
+//{
+//	u8 *n16_old, *p16_old, *n24_old, *p24_old, *n32_old, *p32_old;
+//	u16 *c16_old;
+//	u32 *c24_old;
+//	struct chunk *ck24_old;
+//
+//	spin_lock(&s->lock);
+//
+//	/*Save old pointers*/
+//	n16_old = s->N16;
+//	p16_old = s->P16;
+//	c16_old = s->C16;
+//	n24_old = s->N24;
+//	p24_old = s->P24;
+//	c24_old = s->C24;
+//	ck24_old = s->CK24;
+//	n32_old = s->N32;
+//	p32_old = s->P32;
+//
+//	/*Set the counter before the chunk are deleted*/
+//	s->cnk32_count = 0;
+//	s->cnk24_count = 0;
+//
+//	/*Set the pointers to NULL*/
+//	rcu_assign_pointer(s->N16, NULL);
+//	rcu_assign_pointer(s->P16, NULL);
+//	rcu_assign_pointer(s->C16, NULL);
+//
+//	rcu_assign_pointer(s->N24, NULL);
+//	rcu_assign_pointer(s->P24, NULL);
+//	rcu_assign_pointer(s->C24, NULL);
+//	rcu_assign_pointer(s->CK24, NULL);
+//
+//	rcu_assign_pointer(s->N32, NULL);
+//	rcu_assign_pointer(s->P32, NULL);
+//
+//	/* Wait for all references to be released */
+//	synchronize_rcu();
+//
+//	/* Deallocate old references after setting them NULL*/
+//	kfree(n16_old);
+//	kfree(p16_old);
+//	kfree(c16_old);
+//	kfree(n24_old);
+//	kfree(p24_old);
+//	kfree(c24_old);
+//	kfree(ck24_old);
+//	kfree(n32_old);
+//	kfree(p32_old);
+//
+//	spin_unlock(&s->lock);
+//	return 0;
+//}
+
+
+
+struct per_port_states {
+    /*Number of bytes sent*/    
+    __u64 B;
+    __u64 Q;
+    /*Number of packets received during the control interval*/
+    __u64 n;
+    /*Feedback rate of this router*/
+    __u64 R;
+    __u32 rtt_tot, rtt_a;
+};
+
+static void usage(const char *prog)
+{
+	fprintf(stderr,
+		"usage: %s [OPTS] interface-list\n"
+		"\nOPTS:\n"
+		"    -d    detach program\n"
+		"    -D    direct table lookups (skip fib rules)\n",
+		prog);
+}
+
+static int nr_cpus;
+static int map_fd, prog_fd;
+static struct bpf_object *obj;
+static int xdp_flags = XDP_FLAGS_HW_MODE;
+static int ifindex[NUM_PORTS];
+static char *netdevs[NUM_PORTS];
+static int args_count;
+
+void on_alarm(int signum);
+
+static int do_attach(int idx, int fd, const char *name)
+{
+	int err;
+
+	err = bpf_set_link_xdp_fd(idx, fd, 0);
+	if (err < 0)
+		printf("ERROR: failed to attach program to %s\n", name);
+
+	return err;
+}
+
+static int do_detach(int idx, const char *name)
+{
+	int err;
+
+	err = bpf_set_link_xdp_fd(idx, -1, 0);
+	if (err < 0)
+		printf("ERROR: failed to detach program from %s\n", name);
+
+	return err;
+}
+
+static void int_exit(int sig)
+{
+        int i, err = 0;
+//	bpf_set_link_xdp_fd(ifindex, -1, xdp_flags);
+        
+        for (i = optind; i < args_count; ++i) {
+            err = do_detach(ifindex[i], netdevs[i]);
+            if (err)
+                    printf("Error detaching the program \n");    
+        }
+        
+	exit(0);
+}
+
+static int states_init(struct per_port_states states[], int arr_size)
+{
+    int i = 0;
+    for (; i < arr_size; i++) {
+        states[i].rtt_a = RTT_A_INIT;
+        states[i].R = R_INIT;
+        states[i].rtt_tot = 0;
+        states[i].n = 0;
+        states[i].B = 0;
+        states[i].Q = Q_MAX;        
+    }
+
+    return 0;
+}
+
+static int states_reset(struct per_port_states states[], int arr_size, uint64_t R, uint32_t rtt_a)
+{
+  int i = 0;  
+  for (; i < arr_size; i++) {
+    states[i].rtt_a = rtt_a;
+    states[i].R = R;
+    states[i].rtt_tot = 0;
+    states[i].n = 0;
+    states[i].B = 0;
+    states[i].Q = Q_MAX;      
+  }  
+
+  return 0;
+}
+
+static int calc_rcp_rate(struct per_port_states states[], int arr_size)
+{
+  struct per_port_states res;
+  int i = 0;
+
+  res.Q = 2000000;
+  res.B = 0;
+  
+    for (; i < arr_size; i++) {
+      res.rtt_tot += states[i].rtt_a;
+      res.B += states[i].B;
+      res.n += states[i].n;
+      if(res.Q > states[i].Q)
+          res.Q = states[i].Q;
+    }    
+    __u64 S = states->rtt_a == 0 ? 2000 : 2000 - res.B/states[0].rtt_a;
+    res.rtt_a = states->n == 0 ? 200 : res.rtt_tot/res.n;
+    res.R = states[0].R * (1 + (ALPHA * S - BETA * res.Q/states[0].rtt_a)/C);
+    states_reset(states, arr_size, res.R, res.rtt_a);
+    
+    printf("In calc_rcp_rate. B=%llu RTT_a=%u S=%llu Q=%llu R=%llu \n", states[0].B, states[0].rtt_a, S, states[0].Q, states[0].R);	
+    return 0;
+}
+
+static int states_print(struct per_port_states states[], int arr_size) {
+  int i = 0;  
+  for (; i < arr_size; i++) {
+    printf("%d: B=%llu RTT_a=%u Q=%llu R=%llu n=%llu RTT_tot=%u \n", i, states[i].B, states[i].rtt_a, states[i].Q, states[i].R, states[i].n, states[i].rtt_tot);
+  }  
+
+  return 0;
+}
+
+
+void on_alarm(int signum)
+{
+    struct bpf_map *map;
+    struct per_port_states allstates[nr_cpus];
+    __u32 key = 0;
+    
+    printf("In on_alarm()\n");
+    
+    if (bpf_map_lookup_elem(map_fd, &key, allstates) < 0)
+            return;
+       
+    calc_rcp_rate(allstates, nr_cpus);    
+    
+    if (bpf_map_update_elem(map_fd, &key, allstates, BPF_ANY) != 0) {
+            printf("states_map map update failed: %s\n", strerror(map_fd));
+            return;
+    }
+    
+    ualarm(allstates[0].rtt_a * 1000, 0);  // Reschedule alarm
+}
+
+int main(int argc, char **argv)
+{
+	struct bpf_prog_load_attr prog_load_attr = {
+		.prog_type	= BPF_PROG_TYPE_XDP,
+	};
+	struct bpf_program *prog;
+	char filename[PATH_MAX];
+
+	int attach = 1;
+	int ret = 0;
+        struct bpf_map *map;
+        struct per_port_states allstates[nr_cpus];
+        int opt, i, err;
+        __u32 key = 0;
+        
+	nr_cpus = bpf_num_possible_cpus();
+	printf("nr_cpus:%d\n\n", nr_cpus);
+
+	while ((opt = getopt(argc, argv, ":dD")) != -1) {
+		switch (opt) {
+		case 'd':
+			attach = 0;
+			break;
+		default:
+			usage(basename(argv[0]));
+			return 1;
+		}
+	}
+
+	if (optind == argc) {
+		usage(basename(argv[0]));
+		return 1;
+	}
+
+	if (attach) {
+		snprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);
+		prog_load_attr.file = filename;
+
+		if (access(filename, O_RDONLY) < 0) {
+			printf("error accessing file %s: %s\n",
+				filename, strerror(errno));
+			return 1;
+		}
+		if (bpf_prog_load_xattr(&prog_load_attr, &obj, &prog_fd))
+			return 1;
+
+		prog = bpf_object__find_program_by_title(obj, "sail_lookup");
+		prog_fd = bpf_program__fd(prog);
+		if (prog_fd < 0) {
+			printf("program not found: %s\n", strerror(prog_fd));
+			return 1;
+		}
+                
+                map = bpf_object__find_map_by_name(obj, "states_map");
+		map_fd = bpf_map__fd(map);
+		if (map_fd < 0) {
+			printf("states_map map not found: %s\n", strerror(map_fd));
+			return 1;
+		}
+                
+                states_init(allstates, nr_cpus);
+                
+                //WTF!!! : fix the hack in states_init
+                key = 0;
+                if (bpf_map_update_elem(map_fd, &key, allstates, BPF_ANY) != 0) {
+                        printf("states_map map update failed: %s\n", strerror(map_fd));
+                        return XDP_ABORTED;
+                }
+                
+                signal(SIGINT, int_exit);
+                signal(SIGTERM, int_exit);
+   
+                signal( SIGALRM, on_alarm ); // Install handler first,
+                ualarm(200 * 1000, 0);  //200ms 
+	}
+
+        args_count = argc;
+	for (i = optind; i < argc; ++i) {
+            netdevs[i] = argv[i];
+            ifindex[i] = if_nametoindex(argv[i]);
+            if (!ifindex[i])
+                    ifindex[i] = strtoul(argv[i], NULL, 0);
+            if (!ifindex[i]) {
+                    fprintf(stderr, "Invalid arg\n");
+                    return 1;
+            }
+            err = do_attach(ifindex[i], prog_fd, argv[i]);
+            if (err)
+                    ret = err;
+        }
+
+        while (1) {
+            pause();
+        }       
+        
+	return ret;
+}
